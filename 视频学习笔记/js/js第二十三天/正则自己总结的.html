<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
一 什么是正则表达式
    // 正则表达式(regular expression)是一个描述字符模式的对象;
    // JS定义RegExp类表示正则表达式;
    // String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数;
二 创建正则表达式
    1.创建正则表达式
    // JS提供了两种方法创建正则;一种是采用new运算符,另一种是采用字面量方式;
        (1).var box = new RegExp('box');          // 第一个参数是字符串;
                var box = new RegExp('box','ig'); // 第二个参数是可选模式修饰符;
        (2).var box = /box/;                      // 直接使用两个反斜杠;
                var box = /box/ig;                // 添加模式修饰符;
    2.RegExp对象测试正则表达式
        // RegExp对象包含两个方法:test()和exec();功能基本相似,用于测试字符串匹配;
        (1).test():在字符串中查找是否存在指定的正则表达式并返回布尔值;
        // test()实例
            var pattern = new RegExp('box','i');     // 创建正则;
            var str = 'This is a Box!';              // 创建字符串;
            alert(pattern.test(str));                // 通过test()方法验证是否匹配;
            // 使用一条语句实现正则匹配;
            alert(/box/i.test('This is a box!'));
        (2).exec():在字符串中查找指定正则表达式,若成功,则返回包含该查找字符串的相关信息数组;若失败,返回null;
        exec()实例
            var pattern = /box/i;
            var str = 'This is a Box!';
            alert(pattern.exec(str));                // 匹配返回了数组;
    3.String对象测试正则表达式
        (1).match(pattern):返回pattern中的子串或null;
        // math()方法获取匹配数组;
            var pattern = /box/ig;　　　　　　　　　　　//开启了全局
            var str = 'This is a Box!,That is a Box too!';
            alert(str.match(pattern));               // 得到数组:[Box,Box]
        (2).search(pattern):返回字符串中pattern开始位置;
            var pattern = /box/ig;
            var str = 'This is a Box!,That is a Box too!';
            console.log(str.search(pattern));        // 10;search()查找到即返回,否则返回-1;
        (3).replace(pattern,replacement):用replacement替换pattern;
            var pattern = /box/ig;
            var str = 'This is a Box!,That is a Box too';
            console.log(str.replace(pattern,'Tom')); // 将Box替换成了Tom;
        (4).split(pattern):返回字符串按指定pattern拆分的数组;
            var pattern = / /ig;
            var str = 'This is a Box!, That is a Box too.';
            console.log(str.split(pattern));         // 将空格拆开分组成数组;
三 获取控制
    // 正则表达式元字符是包含特殊含义的字符;
    // 它们有一些特殊功能,可以控制匹配模式的方式;
    // 反斜杠后的元字符将失去其特殊含义;
    1.元字符/元符号    匹配情况
        // 字符类:单个字符和数字
        .                              匹配除换行符外的任意字符;
        [a-z0-9]               　　　　 匹配括号中的字符集中任意字符;
        [^a-z0-9]            　　　　　 匹配不在括号中的字符集中的字符;
        \d                             匹配数字;
        \D                             匹配非数字;
        \w                             匹配字母和数字及_
        \W                             匹配非字母和数字及_
        // 字符类:空白字符
        \0                             匹配null字符;
        \b                             匹配空格字符;
        \f                             匹配进纸字符;
        \n                             匹配换行符;
        \r                             匹配回车字符;
        \t                             匹配制表符;
        \s                             匹配空白字符/空格/制表符和换行符;
        \S                             匹配非空白字符;
        // 字符类:锚字符;
        ^                              行首匹配;
        $                              行尾匹配;
        // 字符类:重复字符;
        x?                             匹配0个或1个x;
        x*                             匹配0个或任意多个x
        x+                             匹配至少一个x;
        (xyz)+                         匹配至少一个(xyz);
        x{m,n}                         匹配最少m个,最多n个x;
        // 字符类:替代字符;
        this|where|logo                匹配this或where或logo中任意一个;
        // 字符类:记录字符;
        $1                             匹配第一个分组中的内容;
        实例:
        pattern = /g..gle/;         // ".":匹配任意一个字符;
        pattern = /g.*gle/;         // ".*":匹配0个或任意多个字符;
        pattern = /g[a-z]*gle/;     // [a-z]*:匹配任意个a-z中的字符;
        pattern = /g[^0-9]*gle/;    // [^0-9]*:匹配任意个非0-9的字符;
        pattern = /[a-z][A-Z]+/;    // [A-Z]+:匹配A-Z中的字符一次或多次
        pattern = /g\w*gle/;        // \w*:匹配任意多个所有字符数字及_;
        pattern = /google\d*/;      // \d*:匹配任意多个数字;
        pattern = /\D{7,}/;         // \D{7,}:匹配至少7个非数字;
        pattern = /^google$/;       // "^":从开头匹配;"$":从结尾匹配;
        var pattern = /8(.*)8/;
        var str = 'This is 8google8';
        str.match(pattern);
        console.log(RegExp.$1);     // 得到第一个分组里的字符串内容;
    2.贪婪和惰性
        +        +?
        ?        ??
        *        *?
        {n}      {n}?
        {n,}     {n,}?
        {n,m} {n,m}?
        var pattern = /[a-z]+?/;        //"?":关闭了贪婪匹配,只替换了第一个;
        var str = 'abcdefg';
        alert(str.replace(pattern,'xxx'));    // =>xxxdefg;
        // 使用exec返回数组
        var pattern = /^[a-z]+\s[0-9]{4}$/i;
        var str  = 'google 2015';
        alert(pattern.exec(str)[0]);    // 返回整个字符串=>google 2015;
        var pattern = /^[a-z]+/i;
        var str = 'google 2015';
        alert(pattern.exec(str));       //返回匹配到的字母=>google;
        // 使用特殊字符匹配;
        var pattern = /\.\[\/b\]/;
        var str = '.[/b]';
        alert(pattern.test(str));
        // 使用换行模式
        var pattern = /^\d+/mg;
        var str = '1.baidu\n2.google\n3.bing';
        var result = str.replace(pattern,"#");
        alert(result);                  // #.baidu  #.google  #.bing;
四 常用的正则
    1.检查邮政编码
        // 共6位数字,第一位不能为0;
        var pattern = /[1-9][0-9]{5}/;
        var str = '224000';
        alert(pattern.test(str));
    2.检查文件压缩包
        // 数字+字母+_+.+zip|rar|gz
        var pattern = /[\w]+\.zip|rar|gz/;
        var str = '123.zip';
        alert(pattern.test(str));
    3.删除多余空格
        var pattern = /\s/g;          // 必须全局,才能全部匹配;
        var str = '111 222 333';
        var result = str.replace(pattern,"");
    4.删除首尾空格
        var pattern = /^\s+/;                        // 强制首;
        var str = '    goo  gle   ';
        var result = str.replace(pattern,"");        // 删除行首空格;
        pattern = /\s+$/;                            // 强制尾;
        result = result.replace(pattern,"");         // 删除行尾空格;
     
    5.简单的电子邮件验证
        var pattern = /^([a-zA-Z0-9_\.\-]+)@([a-zA-Z0-0_\.\-]+)\.([a-zA-Z]{2,4})$/;
        var str = 'abc123.com@gmail.com';
        alert(pattern.test(str));




    </script>
    
</body>
</html>